#!/bin/bash


# Generates a mapping enum value -> enum value name as a string
#
# NOTE: The given enum file must be compilable
#


WE_PATH=..
OUTPUT_DIR=/tmp/generated


# Builds a list of enum files (headers in enums/ folder)
function locate_enums_files()
{
    find $(find "${WE_PATH}" -name enums -type d) -name *.h*
}



# Copy the prototypes from the files generated by awk into a single header
function handle_prototypes()
{
    local prototypes="$OUTPUT_DIR"/enum_print_prototypes.hh

    # Avoiding grep to complain that $prototype is also the input
    rm -f "$prototypes"

    # Copy the prototypes from the generated code
    local gen_files=$(find "$OUTPUT_DIR" -name *.cc)
    for f in $gen_files; do
        grep -rh std::string.*\; "$f" >> "$prototypes"
    done
}



# Generate the printEnum(e_enum value); function
# $1 list of enum files
function generate_print()
{
    if [[ $# -ne 1 ]]; then
        echo "${FUNCNAME[0]}: Expecting 1 filename, received: $@"
        exit 1
    fi
    local enums_list="$1"

    for f in $enums_list; do
        local awk_gen="${OUTPUT_DIR}"/generated_$(basename "$f" .hh).cc

        # Trim comments
        g++ -x c++ -E "$f" > /tmp/$(basename "$f")

        # Invoke the awk script, generating the code
        awk -f $(dirname "$0")/fetch_enums.awk /tmp/$(basename "$f") \
            > "$awk_gen" # --lint

        # Add the include of the enum file
        local include_enum="#include <common/enum/$(basename $f)>"
        sed -i s%'\(include.*\)'%"\1\n$include_enum"% "$awk_gen"
    done
}



# ___________________________________ main ___________________________________ #
function main()
{
    mkdir -p "$OUTPUT_DIR"

    local enums=$(locate_enums_files)
    generate_print "$enums"
    handle_prototypes
}

main


# gen getter / print / operator ?
# return an array: {enum_name, val1, val2, ... } ?
