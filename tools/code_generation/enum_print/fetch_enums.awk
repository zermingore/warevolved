# Fetch the enum class values and content from the C++ provided file
# The file must not contain any comments. Use g++ -E or equivalent to remove them
# before calling this script (or else the behaviour is undefined)
#
# NOTE:
#   Does not handle one-liner enums ('enum class test { a, b, c };')
#   This script is called by generate_enum_print.sh
#
# Arguments:
#   $1: source file name containing the enums
#
# Exits with the status
#   7 if the abort token was found while parsing the file


BEGIN {
  # print "_______________ Fetching enums _______________\n\n"
  in_enum = 0    # Currently parsing an enum
  enum_name = "" # Current enum name

  # should be overwrite redirection; triggers "unnecessary mix of '>' and '>>'"
  print "/* auto-generated by fetch_enums.awk */\n" >> "enum_res"
}


END {
  # print "____________ done fetching enums _____________\n\n"


  # Adding required headers
  printf("// auto-generated code, edit at your own risks\n")
  printf("// generator: \n")
  printf("// generated on: %s\n", strftime())
  print ""
  print ""
  printf("#include <string>\n")
  print ""
  print "namespace debug {"
  print ""

  # Generating prototypes
  for (enums in res)
  {
    # Prototype
    printf("std::string %s_string(%s entry);\n", enums, enums)
  }
  print ""


  for (enums in res)
  {
    # print enums
    printf("std::string %s_string(%s entry)\n", enums, enums)
    printf "{\n"
    printf("  switch (entry)\n")
    printf "  {\n"
    for (values in res[enums])
    {
      # Removing eventual coma in the enum entry name
      gsub(",", "", res[enums][values]["entry"])

      printf "    case %s::%s:\n", enums, res[enums][values]["entry"]
      printf "      return \"%s::%s", enums, res[enums][values]["entry"]

      # if (res[enums][values]["value"] != "")
      if (length(res[enums][values]) > 1)
      {
        printf " (%s)", res[enums][values]["value"]
      }
      else
        printf " (no explicit value)"

      printf "\";\n"
    }

    printf "    default:\n"
    printf "      return \"entry not matched\";\n"

    printf "  }\n"
    printf "}\n"
  }

  print ""
  print "} // namespace debug"

  close("enum_res")
}

# BEGINFILE {
#   print "Fetching enums in $FILENAME"
# }

# Debug: Allow skipping the rest of the file
/ABORT/ {
  print "Found abort token, aborting"
  exit 7
}

/^#/ {
  next
}

# enum found
/enum\ class/ {
  in_enum = 1
  nb_val = 0

  # Change the field separator (enum class NAME: int)
  old_fs = FS
  FS = "[ :]"

  # gsub(".*enum class(.*)","")
  gsub("enum class *","")
  enum_name = $1

  # printf ">> Found enum |%s|\n", enum_name

  # Restore the current field separator
  FS = old_fs

  next
}


# Try to locate the enum begin
#/\s*{.*/ {


# Enum end
/.*};.*/ {
  # printf "<< End enum |%s|\n\n", enum_name

  in_enum = 0
  enum_name = ""

  next
}


# enum values
/.*/ {
  # skip everything as long as we're not in an enum
  if (in_enum != 1)
    next

  # remove empty line
  if ($0 ~ /^[:blank:]*$/)
    next

  if ($0 ~ " *{ *")
  {
    # print "---------- Values ----------"
    next
  }


  # expecting entry [= val][,]
  old_fs = FS
  FS = "[=,]"

  # get the enum entry
  gsub("*","")

  entry = $1
  printf "|%s|_", $1 >> "enum_res"

  if ($3)
  {
    value = $3

    # get the value, excluding the eventual ','
    tab["empty"] = 1
    if (match(value, "(.*),", tab) == 0)
      val = $3
    else
      val = tab[1]

    printf "|%s|\n", val >> "enum_res"

    res[enum_name][nb_val]["value"] = val
  }

  res[enum_name][nb_val]["entry"] = entry

  nb_val++

  FS = old_fs

  next
}
