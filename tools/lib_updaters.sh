#/bin/sh

set -u


get_last_version_from_repo()
{
  repo_url=$1
  version_pattern=$2
  local_version=$3

  # Get the last remote version
  online_last_version=$(git ls-remote --tags "$repo_url" \
                          | egrep -o "$version_pattern" \
                          | sort -V \
                          | tail -n 1)
  if [ $? -ne 0 -o -z $online_last_version ]; then
    echo "Error: Cannot retrieve online version."
    return 1
  fi
  LAST_VERSION="$online_last_version"

  # Stop here if the version is already actual
  if [ "$local_version" = "$online_last_version" ]; then
    echo "Already using the last version $online_last_version"
    return 0 # ok but don't continue
  fi

  echo "Will try to update from $local_version to $online_last_version"
  return 3 # ok, continue
}




check_license()
{
  local_path=$1
  destination_clone=$2
  license_file=$3

  cmp ${local_path}/${license_file} ${destination_clone}/${license_file}
  if [ $? -eq 0 ]; then
    echo "(No license modification)"
    return 0
  fi

  echo "*Warning* LICENSE modification:"
  echo "Diff ${license_file}"
  echo "current: ${local_path} | new: ${destination_clone}"
  diff ${local_path}/${license_file} ${destination_clone}/${license_file}

  echo "Press any key to continue. (or abort with C-c)"
  read
}



# Checkout the current version to update the local one
clone()
{
  if [ $# -ne 3 ]; then
    echo "[IMPLEMENTATION ERROR] clone() Invalid args"
    echo "Received [$@]"
    exit 99
  fi

  repo_url=$1
  last_version=$2
  destination=$3

  git clone -c advice.detachedHead=false -q \
      --branch "$last_version" --depth 1 "$repo_url" "$destination"
  if [ $? -ne 0 ]; then
    echo "*ERROR* Cannot clone [${repo_url}] (v${LAST_VERSION}). Aborting..."
    echo "(The $# arguments to clone function were: [$@])"
    return 1
  fi
}



# Backup the current version
backup()
{
  if [ $# -ne 1 ]; then
    echo "[IMPLEMENTATION ERROR] backup() Invalid args"
    echo "Received [$@]"
    exit 99
  fi

  local_path=$1

  rm -rf "${local_path}_old"
  mv ${local_path} ${local_path}_old
  if [ $? -ne 0 ]; then
    echo "Cannot move [${local_path}] to [${local_path}_old]"
    exit 1
  fi
  mkdir -p ${local_path}
}



# Update the relevant files
# Expecting at least as arguments:
# cloned_repository_path local_destination license_file first_source_file
update()
{
  if [ $# -lt 4 ]; then # cloned_repo source license source optional_files...
    echo "[IMPLEMENTATION ERROR] update() Missing arguments"
    echo "Received [$@]"
    exit 99
  fi

  cloned_repository_path=$1
  shift
  local_destination=$1
  shift
  other_files=$@

  echo "Copying:"
  for f in $other_files; do
    cp -iv ${cloned_repository_path}/$f ${local_destination}/
  done
}



# _____________________________ doctest specific _____________________________ #
update_doctest()
{
  lib=doctest
  repo=https://github.com/doctest/doctest.git
  license_file=LICENSE.txt
  readme=README.md
  header=doctest.h
  header_path_repo=doctest/
  local_path=tests/unit/lib

  echo
  echo ">>> $lib <<<"

  # Sanity check: do the requested files exist locally?
  if [ ! -f "${local_path}/${header}" -o ! -f "${local_path}/${license_file}" ]; then
    echo "ERROR: Cannot find the local files"
    echo "looked in [${local_path}] for:"
    echo "- [$header]"
    echo "- [$license_file]"
    return 1
  fi

  # Parse local version (library specific)
  hdr="${local_path}/${header}"
  major=$(grep -m 1 '^#define DOCTEST_VERSION_MAJOR ' ${hdr} | grep -o '[0-9]*')
  minor=$(grep -m 1 '^#define DOCTEST_VERSION_MINOR ' ${hdr} | grep -o '[0-9]*')
  patch=$(grep -m 1 '^#define DOCTEST_VERSION_PATCH ' ${hdr} | grep -o '[0-9]*')
  local_version="v${major}.${minor}.${patch}"

  get_last_version_from_repo $repo 'v?[0-9]+(\.[0-9]*)*' $local_version
  ret_code=$?
  if [ $ret_code -ne 3 ]; then
    return $ret_code # Update not needed or possible
  fi

  destination_clone=/tmp/${lib}_$(date +%s)
  clone "$repo" "$LAST_VERSION" "$destination_clone" || return $?
  check_license $local_path $destination_clone $license_file

  backup $local_path

  update ${destination_clone} ${local_path} ${license_file} ${readme} \
         "${header_path_repo}/${header}"

  # Update the version in the custom VERSION file
  echo "$LAST_VERSION (generated by $0)" > ${local_path}/VERSION
}



# _____________________________ pugixml specific _____________________________ #
update_pugixml()
{
  lib=pugixml
  repo=https://github.com/zeux/pugixml.git
  license_file=LICENSE.md
  readme=readme.txt
  version_pattern='[0-9]+(\.[0-9]*)*'
  local_path=lib/pugixml

  echo
  echo ">>> $lib <<<"

  # Sanity check: do the requested files exist locally?
  if [ ! -d "${local_path}" ]; then
    echo "ERROR: Cannot find the local version"
    return 1
  fi

  # Get the current used release
  version_line=$(grep '^ \* pugixml parser - version ' $local_path/pugixml.hpp)
  local_version=$(echo "$version_line" | egrep -o $version_pattern)
  if [ -z "$version_line" -o -z "$local_version" ]; then
    echo "Cannot identify local version. Aborting..."
    return 1
  fi
  local_version=v${local_version}

  get_last_version_from_repo $repo v${version_pattern} $local_version
  ret_code=$?
  if [ $ret_code -ne 3 ]; then
    return $ret_code # Update not needed or possible
  fi

  destination_clone=/tmp/${lib}_$(date +%s)
  clone "$repo" "$LAST_VERSION" "$destination_clone" || return $?
  check_license $local_path $destination_clone $license_file

  backup $local_path

  update ${destination_clone} ${local_path} ${license_file} ${readme} \
         "src/pugiconfig.hpp" "src/pugixml.hpp" "src/pugixml.cpp"

  # Update  version in the custom VERSION file
  echo "$LAST_VERSION (generated by $0)" > ${local_path}/VERSION
}



# ___________________________________ main __________________________________ #
main()
{
  update_doctest
  ret_code=$?

  update_pugixml
  ret_code=$(($? + ret_code))

  if [ $ret_code -eq 0 ]; then
    echo "Note: This script does not make any commit or track / un-track files"
  fi
}

main
